# Circuit-SAT-solver

## Description

Проект реализует простое консольное приложение, 
которое на вход принимает название солвера, тестовую схему в формате bench 
и ограничение на максимальное время работы.
Приложение выводит в консоль результат работы `SAT`, `UnSAT` 
или `Unknown` если солверу не удалось найти ответ за указанное время.
Также выводит название запускаемой схемы и затраченное время на выполнение. 

## Project structure

* [data/benchs_for_test](data/benchs_for_test) набор схем для проведения бенчмарков
* [data/benchmarks](data/benchmarks) результаты запусков солверов на тестовых схемах
* [lib](lib) основная библиотека, содержащая в себе всю логику приложения 
* [tests](tests) тесты корректности работы приложения
* [third_party](third_party) зависимости приложения
* [benchmark.sh](benchmark.sh) скрипт для проведелния бенчмарков решения

## Solvers

Ниже приведены описания реализованных солверов

### BruteForceSolver

Солвер, перебирающий все возможные `2^n` входов, где `n` - количество входов. 
При переборе пересчитывает не все гейты, а только те, что меняются относительно предыдущего состояния перебора. 
В остальном работает очень неэффективно. 
Используется в качестве базового решения для проверки корректности других солверов. 

### CNFReductionSolver

Солвер, решающий задачу сведением к `3-SAT` и вызовом SAT-солвера `cryptominisat`.

Результаты бенчмарков данного солвера можно найти в [этом файле](data/benchmarks/CNFReductionSolver-10112023-205847.txt)

### OptimizedEnumerationSolver

Моя собственная версия солвера. Использует полный перебор с эвристиками. 
Основная идея состоит в том, чтобы перебирать гейты схемы сверху вниз от выходного гейта.
Для простоты реализации спуска по схеме, вершины перебираются в порядке топологической сортировки
(таким образом, обходим схему в понятном фиксированном порядке. 
При этом посещаем только влияющие на ответ вершины). 
При выборе значения гейта проверяется его непротиворечивость с выбранными ранее значениями. 

Основной реализованной эвристикой является следующая идея: 
если гейту `g` установили значения `val` и существует ровно одна пара аргументов, 
`arg1`, `arg2`, такая что `g(arg1, arg2) = val`, то сразу же понимаем, что гейтам `gate1`, `gate2`,
(от которых зависит `g`) надо задать значения `arg1`, `arg2` соответственно. 
При этом выстраиваем целые цепочки таких следствий, тем самым при установлении `g = val`, 
потенциально устанавливаем сразу большое количество значений. Что позволяет нам быстрее обнаружить противоречия
(если такие имеются) и отрезать ветку перебора. 

Ещё одной эвристикой является поиск позиции, на которой произошёл конфликт.
Пусть попробовали гейту `i` задать значение `True` и получили, что 
данное значение конфликтует с гейти на позиции `c1` в топологической сортировке, 
а значение `False` конфликтует со значением гейта на позиции `c2`.
Тогда понятно, что никакая, что схема невыполнима с данными значениями гейтов `g_c1`, `g_c2`. 
Значит значение одного из гейтов надо поменять. Поэтому перебор с позиции `i` откатывается до `max(c1, c2)`, что тоже 
отрезает ветви перебора.

*TODO: к сожалению, на данный момент данный солвер работает нестабильно и на некоторых входах получает segmentation fault.
И видимо я уже не успеваю найти и исправить ошибку*

*TODO: доделать бенчмарки данного солвера*

## Improvement ideas

Здесь описаны некоторые мои идеи того, как можно улучить солвер, которые я не успел реализовать.

### Точки сочленения 

Понятно, что если какой-то гейт является точкой сочлениеия, 
то можно отдельно проверить, может ли он быть равен как `True`, так и `False`. 
И в зависимости от результата заменить его либо на обычный вход из одной вершины, 
либо на константу. 

### Локальные улучшения схемы

Можно пробежать по подсхемам, зависящим от не более чем `k` гейтов, 
и заменить такие подсхемы на оптимальные, вычисляющие ту же функцию. 
Как минимум, эту идею можно применить для `k = 1`, чтобы убрать гейты, принимающие 
один и тот же гейт в качестве двух входов. Для `k = 2, 3` тоже нетрудно получить улучшения. Ведь оптимальные схемы 
можно явно все перечислить. А вот при `k > 3` уже становится сложнее. Ведь схем уже более `2^32`. 
Трудность поиска ответа при больших `k` описана в [SAT-based Circuit Local Improvement](https://arxiv.org/abs/2102.12579).
Поэтому можно поперебирать подсхемы, зависязие от не более трёх входов относительно безболезненно. Для бОльших `k` 
тоже можно попробовать поискать улучшения эвристически. Но конкретный подход без эксперимнетов предложить трудно. 

### Более детальные поиски противоречий

На данный момент в солвере реализованы эвристики для таких функций как `OR` и `AND`. 
Здесь используется идея "иногда, зная значения функции, можем узнать оба аргумента".
Тем не менее этот подход можно расширить до "иногда, зная значения функции и один из аргументов, можем узнать второй аргумент".
Это, например, верно для таких функций как `XOR` и `NXOR`. 
Таким образом, можно построить более длинные цепочки зависимостей между переменными и эффективнее искать противоречия.

## Build

1. `git clone https://github.com/Seva-Vaskin/Circuit-SAT-solver.git`
2. `cd Circuit-SAT-solver`
3. `git submodule update --init --recursive`
4. `cmake -DCMAKE_BUILD_TYPE=Release -S . -B cmake-build-release`
5. `cmake --build cmake-build-release --target CircuitSATSolver`

## Testing

Корректность солверов проверяется тестами, описанными в файле [SolversTest.cpp](tests/SolversTest.cpp) 